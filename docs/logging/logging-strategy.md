# استراتژی مدیریت لاگ‌ها در PicSend

## ساختار پوشه‌ها

```
logs/
├── server-3010/
│   ├── error/            # لاگ‌های خطا
│   ├── info/             # لاگ‌های اطلاعات
│   └── debug/            # لاگ‌های دیباگ
└── client-3005/
    ├── error/            # خطاهای فرانت‌اند
    ├── info/             # اطلاعات عملکرد
    └── debug/            # اطلاعات تحلیلی کاربران

## سطوح لاگ
- ERROR: خطاهای بحرانی که نیاز به توجه فوری دارند
- WARN: هشدارها و مشکلات غیر بحرانی
- INFO: اطلاعات عمومی و رویدادهای مهم سیستم
- DEBUG: اطلاعات جزئی برای عیب‌یابی
- TRACE: جزئی‌ترین سطح اطلاعات برای تحلیل دقیق

## استراتژی لاگینگ در سمت سرور

### ابزارها و کتابخانه‌ها
- Winston برای مدیریت لاگ‌ها
- Morgan برای لاگ کردن درخواست‌های HTTP
- Winston Daily Rotate File برای چرخش خودکار فایل‌های لاگ

### نمونه ساختار لاگ
```json
{
  "timestamp": "2024-03-12T10:30:00.000Z",
  "level": "ERROR",
  "service": "auth-service",
  "message": "خطا در احراز هویت کاربر",
  "metadata": {
    "userId": "123",
    "requestId": "req-456",
    "path": "/api/auth",
    "method": "POST"
  },
  "stack": "..."
}
```

### سیاست نگهداری لاگ‌ها
- لاگ‌های خطا: 30 روز
- لاگ‌های دسترسی: 7 روز
- لاگ‌های دیباگ: 3 روز
- حداکثر حجم هر فایل: 10MB
- چرخش خودکار فایل‌ها در نیمه شب

## استراتژی لاگینگ در سمت کلاینت

### ابزارها
- کتابخانه `debug` برای لاگینگ در محیط توسعه
- Sentry برای ردیابی خطاها در محیط تولید
- Performance API برای لاگ‌های عملکردی

### موارد ثبت شده
1. خطاهای برنامه:
   - خطاهای شبکه
   - خطاهای رندر
   - خطاهای نامشخص (uncaught exceptions)

2. عملکرد:
   - زمان بارگذاری صفحه
   - تأخیر در درخواست‌های API
   - عملکرد کامپوننت‌ها

3. تعامل کاربر:
   - مسیرهای ناوبری
   - عملیات مهم کاربر
   - خطاهای ورودی کاربر

### نمونه پیاده‌سازی در فرانت‌اند
```typescript
interface LogEntry {
  level: 'error' | 'warn' | 'info' | 'debug';
  message: string;
  timestamp: string;
  data?: Record<string, unknown>;
}

class ClientLogger {
  static log(level: LogEntry['level'], message: string, data?: Record<string, unknown>) {
    const entry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      data
    };
    
    // ارسال به سرور در صورت نیاز
    if (level === 'error' || level === 'warn') {
      this.sendToServer(entry);
    }
    
    // ذخیره در localStorage برای دیباگ
    this.storeLocally(entry);
  }
}
```

## مانیتورینگ و هشدارها

### سیستم هشدار
- ایمیل برای خطاهای بحرانی
- نوتیفیکیشن در Slack برای هشدارها
- پیامک برای مشکلات حیاتی سیستم

### معیارهای هشدار
- تعداد خطاهای 500 در دقیقه > 10
- زمان پاسخ‌گویی API > 2 ثانیه
- نرخ خطای درخواست‌ها > 5%

## ابزارهای تحلیل لاگ

### ابزارهای پیشنهادی
- Kibana برای تحلیل و ویژوالایز کردن لاگ‌ها
- Grafana برای داشبوردهای مانیتورینگ
- Prometheus برای جمع‌آوری متریک‌ها

### گزارش‌های دوره‌ای
- گزارش روزانه خطاهای بحرانی
- گزارش هفتگی عملکرد سیستم
- گزارش ماهانه روندها و الگوها

## بهترین شیوه‌های کاربردی

1. **محرمانگی داده‌ها**
   - حذف اطلاعات حساس (مانند پسورد)
   - رمزنگاری داده‌های شخصی
   - رعایت GDPR و قوانین حریم خصوصی

2. **مدیریت حجم**
   - فشرده‌سازی لاگ‌های قدیمی
   - حذف خودکار لاگ‌های غیرضروری
   - نمونه‌برداری از لاگ‌های پرتکرار

3. **عیب‌یابی مؤثر**
   - استفاده از requestId برای ردیابی
   - ثبت context کافی در هر لاگ
   - دسته‌بندی مناسب خطاها

## پیاده‌سازی

1. **گام اول: راه‌اندازی زیرساخت**
   - ایجاد پوشه‌های لاگ
   - نصب و پیکربندی Winston
   - تنظیم rotation لاگ‌ها

2. **گام دوم: پیاده‌سازی سرور**
   - پیکربندی middleware‌های لاگینگ
   - تنظیم فرمت‌های لاگ
   - پیاده‌سازی error handling

3. **گام سوم: پیاده‌سازی کلاینت**
   - راه‌اندازی Sentry
   - پیاده‌سازی error boundary‌ها
   - تنظیم لاگینگ عملکرد

4. **گام چهارم: مانیتورینگ**
   - راه‌اندازی Kibana/Grafana
   - تنظیم هشدارها
   - ایجاد داشبوردها

## معماری کلی

سیستم لاگینگ از یک معماری مرکزی استفاده می‌کند که شامل اجزای زیر است:

1. **سرور لاگینگ مرکزی**
   - پورت: 3015
   - مسئول جمع‌آوری و ذخیره‌سازی لاگ‌ها
   - ارائه داشبورد مدیریت لاگ‌ها
   - پشتیبانی از Socket.IO برای لاگ‌های زنده
   - ذخیره‌سازی لاگ‌ها با تفکیک سرویس و سطح

2. **کلاینت‌های لاگینگ**
   - کلاینت سمت سرور (پورت 3010)
   - کلاینت سمت فرانت‌اند (پورت 3005)
   - ارسال لاگ‌ها از طریق HTTP و Socket.IO
   - پشتیبانی از ذخیره موقت در localStorage

## سطوح لاگینگ

سیستم از چهار سطح لاگینگ پشتیبانی می‌کند:

1. **Error**: خطاهای برنامه که نیاز به توجه فوری دارند
2. **Warning**: هشدارها و مشکلات بالقوه
3. **Info**: اطلاعات عمومی و رویدادهای مهم
4. **Debug**: اطلاعات جزئی برای عیب‌یابی

## ساختار فایل‌های لاگ

لاگ‌ها در پوشه `logs` با ساختار زیر ذخیره می‌شوند:

```
logs/
├── server-3010/
│   ├── error/
│   ├── info/
│   └── debug/
└── client-3005/
    ├── error/
    ├── info/
    └── debug/
```

هر فایل لاگ با فرمت `{level}-YYYY-MM-DD.log` ذخیره می‌شود و به صورت خودکار بعد از رسیدن به حجم 10MB چرخش می‌کند.

## داشبورد مدیریت لاگ‌ها

داشبورد در آدرس `http://localhost:3015/dashboard` در دسترس است و قابلیت‌های زیر را ارائه می‌دهد:

1. **نمایش آمار**
   - تعداد کل لاگ‌ها
   - تعداد لاگ‌ها به تفکیک سطح
   - نمودار توزیع لاگ‌ها
   - نمودار روند لاگ‌ها در طول زمان

2. **فیلترها**
   - فیلتر بر اساس سرویس
   - فیلتر بر اساس سطح لاگ
   - فیلتر بر اساس بازه زمانی

3. **قابلیت‌های ویژه**
   - نمایش زنده لاگ‌ها
   - خروجی گرفتن از لاگ‌ها
   - جستجو و فیلتر پیشرفته
   - نمایش جزئیات کامل هر لاگ

## نحوه استفاده

### در سمت سرور

```typescript
import { loggingClient } from './utils/loggingClient';

// ثبت خطا
loggingClient.error('خطای اتصال به دیتابیس', { 
  error: err.message,
  connectionParams 
});

// ثبت هشدار
loggingClient.warn('تلاش ناموفق برای ورود', { 
  username,
  attempts 
});

// ثبت اطلاعات
loggingClient.info('کاربر جدید ثبت‌نام کرد', { 
  userId,
  email 
});

// ثبت دیباگ
loggingClient.debug('اطلاعات درخواست', { 
  method,
  path,
  params 
});
```

### در سمت کلاینت

```typescript
import { loggingClient } from './utils/loggingClient';

// ثبت خطا
loggingClient.error('خطای اجرای API', {
  endpoint,
  error: err.message
});

// ثبت اطلاعات عملکرد
loggingClient.info('زمان بارگذاری صفحه', {
  page,
  loadTime: performance.now()
});
```

## مدیریت خطاها

1. **قطع ارتباط با سرور لاگینگ**
   - لاگ‌ها در localStorage ذخیره می‌شوند
   - پس از برقراری مجدد ارتباط، به صورت خودکار ارسال می‌شوند

2. **محدودیت حجم**
   - چرخش خودکار فایل‌ها بعد از 10MB
   - نگهداری لاگ‌ها تا 30 روز
   - فشرده‌سازی فایل‌های قدیمی

## بهترین شیوه‌ها

1. **ساختار لاگ‌ها**
   - استفاده از پیام‌های توصیفی و مختصر
   - افزودن متادیتای مرتبط و مفید
   - استفاده از سطح لاگ مناسب

2. **عملکرد**
   - استفاده از Socket.IO برای لاگ‌های زنده
   - ذخیره موقت در localStorage در صورت قطعی
   - محدود کردن حجم لاگ‌ها

3. **امنیت**
   - عدم لاگ کردن اطلاعات حساس
   - رمزنگاری اطلاعات حساس در صورت نیاز
   - محدود کردن دسترسی به داشبورد

## نگهداری

1. **پاکسازی خودکار**
   - حذف لاگ‌های قدیمی‌تر از 30 روز
   - فشرده‌سازی فایل‌های قدیمی
   - مدیریت فضای دیسک

2. **پشتیبان‌گیری**
   - پشتیبان‌گیری روزانه از لاگ‌ها
   - نگهداری در مکان امن
   - امکان بازیابی سریع 